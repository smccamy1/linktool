[
    {
        "id": "prefetch_tab",
        "type": "tab",
        "label": "Prefetch Control Example",
        "disabled": false,
        "info": "Demonstrates prefetch control - Fast worker (prefetch=3) vs Slow worker (prefetch=1)"
    },
    {
        "id": "inject_prefetch_task",
        "type": "inject",
        "z": "prefetch_tab",
        "name": "Send Task",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 80,
        "wires": [["create_prefetch_task"]]
    },
    {
        "id": "inject_prefetch_batch",
        "type": "inject",
        "z": "prefetch_tab",
        "name": "Send 20 Tasks",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "20",
        "payloadType": "num",
        "x": 130,
        "y": 120,
        "wires": [["create_prefetch_batch"]]
    },
    {
        "id": "create_prefetch_task",
        "type": "function",
        "z": "prefetch_tab",
        "name": "Create Task",
        "func": "const taskId = Math.floor(Math.random() * 10000);\n\nmsg.payload = {\n    taskId: taskId,\n    type: 'data_processing',\n    data: `Task ${taskId}`,\n    timestamp: new Date().toISOString(),\n    processingTime: 2000 // 2 seconds\n};\n\nnode.status({fill:\"blue\",shape:\"dot\",text:`Created task ${taskId}`});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 80,
        "wires": [["send_prefetch_queue", "debug_prefetch_created"]]
    },
    {
        "id": "create_prefetch_batch",
        "type": "function",
        "z": "prefetch_tab",
        "name": "Create Batch",
        "func": "const count = msg.payload || 20;\nconst messages = [];\n\nfor (let i = 0; i < count; i++) {\n    const taskId = Math.floor(Math.random() * 10000);\n    messages.push({\n        payload: {\n            taskId: taskId,\n            type: 'data_processing',\n            data: `Task ${taskId}`,\n            timestamp: new Date().toISOString(),\n            processingTime: 2000\n        }\n    });\n}\n\nnode.status({fill:\"blue\",shape:\"dot\",text:`Created ${count} tasks`});\nreturn [messages];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 120,
        "wires": [["send_prefetch_queue"]]
    },
    {
        "id": "send_prefetch_queue",
        "type": "function",
        "z": "prefetch_tab",
        "name": "Send to Queue",
        "func": "const amqp = global.get('amqplib') || amqplib;\nif (!global.get('amqplib')) {\n    global.set('amqplib', amqplib);\n}\n\nconst url = 'amqp://admin:rabbitmqpass123@rabbitmq:5672';\n\n(async () => {\n    try {\n        const connection = await amqp.connect(url);\n        const channel = await connection.createChannel();\n        \n        const queueName = 'prefetch_queue';\n        await channel.assertQueue(queueName, { durable: true });\n        \n        const message = JSON.stringify(msg.payload);\n        channel.sendToQueue(queueName, Buffer.from(message), { persistent: true });\n        \n        node.status({fill:\"green\",shape:\"dot\",text:`Sent task ${msg.payload.taskId}`});\n        \n        setTimeout(() => {\n            channel.close();\n            connection.close();\n        }, 500);\n        \n    } catch (error) {\n        node.error(`Error: ${error.message}`, msg);\n        node.status({fill:\"red\",shape:\"ring\",text:\"error\"});\n    }\n})();\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [{"var": "amqplib", "module": "amqplib"}],
        "x": 550,
        "y": 100,
        "wires": []
    },
    {
        "id": "fast_worker_consumer",
        "type": "function",
        "z": "prefetch_tab",
        "name": "Fast Worker (prefetch=3)",
        "func": "const amqp = global.get('amqplib') || amqplib;\nif (!global.get('amqplib')) {\n    global.set('amqplib', amqplib);\n}\n\nconst url = 'amqp://admin:rabbitmqpass123@rabbitmq:5672';\n\nif (!context.get('fast_worker_connection')) {\n    (async () => {\n        try {\n            const connection = await amqp.connect(url);\n            const channel = await connection.createChannel();\n            \n            const queueName = 'prefetch_queue';\n            await channel.assertQueue(queueName, { durable: true });\n            \n            // PREFETCH = 3: This worker can handle 3 tasks simultaneously\n            channel.prefetch(3);\n            \n            let activeTaskCount = 0;\n            \n            channel.consume(queueName, (msg) => {\n                if (msg) {\n                    const content = msg.content.toString();\n                    try {\n                        const task = JSON.parse(content);\n                        activeTaskCount++;\n                        node.status({fill:\"yellow\",shape:\"dot\",text:`Processing ${activeTaskCount} tasks`});\n                        \n                        node.send({\n                            payload: task,\n                            _msgid: msg.properties.messageId,\n                            acknowledge: () => {\n                                channel.ack(msg);\n                                activeTaskCount--;\n                                node.status({fill:\"green\",shape:\"dot\",text:`Processing ${activeTaskCount} tasks`});\n                            }\n                        });\n                    } catch (e) {\n                        node.error(`Parse error: ${e.message}`);\n                        channel.nack(msg, false, false);\n                    }\n                }\n            }, { noAck: false });\n            \n            context.set('fast_worker_connection', { connection, channel });\n            node.status({fill:\"green\",shape:\"dot\",text:\"Ready (prefetch=3)\"});\n            \n        } catch (error) {\n            node.error(`Connection error: ${error.message}`);\n            node.status({fill:\"red\",shape:\"ring\",text:\"error\"});\n        }\n    })();\n} else {\n    node.status({fill:\"green\",shape:\"dot\",text:\"Ready (prefetch=3)\"});\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "const conn = context.get('fast_worker_connection');\nif (conn) {\n    try {\n        conn.channel.close();\n        conn.connection.close();\n    } catch (e) {}\n    context.set('fast_worker_connection', null);\n}",
        "libs": [{"var": "amqplib", "module": "amqplib"}],
        "x": 170,
        "y": 240,
        "wires": [["process_fast_worker"]]
    },
    {
        "id": "slow_worker_consumer",
        "type": "function",
        "z": "prefetch_tab",
        "name": "Slow Worker (prefetch=1)",
        "func": "const amqp = global.get('amqplib') || amqplib;\nif (!global.get('amqplib')) {\n    global.set('amqplib', amqplib);\n}\n\nconst url = 'amqp://admin:rabbitmqpass123@rabbitmq:5672';\n\nif (!context.get('slow_worker_connection')) {\n    (async () => {\n        try {\n            const connection = await amqp.connect(url);\n            const channel = await connection.createChannel();\n            \n            const queueName = 'prefetch_queue';\n            await channel.assertQueue(queueName, { durable: true });\n            \n            // PREFETCH = 1: This worker can only handle 1 task at a time\n            channel.prefetch(1);\n            \n            channel.consume(queueName, (msg) => {\n                if (msg) {\n                    const content = msg.content.toString();\n                    try {\n                        const task = JSON.parse(content);\n                        node.status({fill:\"yellow\",shape:\"ring\",text:`Processing task`});\n                        \n                        node.send({\n                            payload: task,\n                            _msgid: msg.properties.messageId,\n                            acknowledge: () => {\n                                channel.ack(msg);\n                                node.status({fill:\"green\",shape:\"dot\",text:\"Ready (prefetch=1)\"});\n                            }\n                        });\n                    } catch (e) {\n                        node.error(`Parse error: ${e.message}`);\n                        channel.nack(msg, false, false);\n                    }\n                }\n            }, { noAck: false });\n            \n            context.set('slow_worker_connection', { connection, channel });\n            node.status({fill:\"green\",shape:\"dot\",text:\"Ready (prefetch=1)\"});\n            \n        } catch (error) {\n            node.error(`Connection error: ${error.message}`);\n            node.status({fill:\"red\",shape:\"ring\",text:\"error\"});\n        }\n    })();\n} else {\n    node.status({fill:\"green\",shape:\"dot\",text:\"Ready (prefetch=1)\"});\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "const conn = context.get('slow_worker_connection');\nif (conn) {\n    try {\n        conn.channel.close();\n        conn.connection.close();\n    } catch (e) {}\n    context.set('slow_worker_connection', null);\n}",
        "libs": [{"var": "amqplib", "module": "amqplib"}],
        "x": 170,
        "y": 340,
        "wires": [["process_slow_worker"]]
    },
    {
        "id": "process_fast_worker",
        "type": "function",
        "z": "prefetch_tab",
        "name": "Process (Fast)",
        "func": "const task = msg.payload;\nconst processingTime = task.processingTime || 2000;\nconst acknowledge = msg.acknowledge;\n\nnode.status({fill:\"yellow\",shape:\"ring\",text:`Processing ${task.taskId}`});\n\nsetTimeout(() => {\n    msg.payload = {\n        ...task,\n        worker: 'Fast Worker (prefetch=3)',\n        status: 'completed',\n        completedAt: new Date().toISOString()\n    };\n    \n    if (acknowledge) acknowledge();\n    \n    node.status({fill:\"green\",shape:\"dot\",text:`Done ${task.taskId}`});\n    node.send(msg);\n}, processingTime);\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 240,
        "wires": [["debug_fast_completed"]]
    },
    {
        "id": "process_slow_worker",
        "type": "function",
        "z": "prefetch_tab",
        "name": "Process (Slow)",
        "func": "const task = msg.payload;\nconst processingTime = (task.processingTime || 2000) * 2; // Takes 2x longer\nconst acknowledge = msg.acknowledge;\n\nnode.status({fill:\"yellow\",shape:\"ring\",text:`Processing ${task.taskId}`});\n\nsetTimeout(() => {\n    msg.payload = {\n        ...task,\n        worker: 'Slow Worker (prefetch=1)',\n        status: 'completed',\n        completedAt: new Date().toISOString()\n    };\n    \n    if (acknowledge) acknowledge();\n    \n    node.status({fill:\"green\",shape:\"dot\",text:`Done ${task.taskId}`});\n    node.send(msg);\n}, processingTime);\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 340,
        "wires": [["debug_slow_completed"]]
    },
    {
        "id": "start_fast_worker",
        "type": "inject",
        "z": "prefetch_tab",
        "name": "Start Fast Worker",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "x": 150,
        "y": 200,
        "wires": [["fast_worker_consumer"]]
    },
    {
        "id": "start_slow_worker",
        "type": "inject",
        "z": "prefetch_tab",
        "name": "Start Slow Worker",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "x": 150,
        "y": 380,
        "wires": [["slow_worker_consumer"]]
    },
    {
        "id": "debug_prefetch_created",
        "type": "debug",
        "z": "prefetch_tab",
        "name": "Task Created",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 550,
        "y": 40,
        "wires": []
    },
    {
        "id": "debug_fast_completed",
        "type": "debug",
        "z": "prefetch_tab",
        "name": "Fast Worker Done",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 240,
        "wires": []
    },
    {
        "id": "debug_slow_completed",
        "type": "debug",
        "z": "prefetch_tab",
        "name": "Slow Worker Done",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 340,
        "wires": []
    },
    {
        "id": "comment_prefetch",
        "type": "comment",
        "z": "prefetch_tab",
        "name": "Prefetch Control: Fast worker can handle 3 tasks at once, slow worker only 1",
        "info": "**How Prefetch Works:**\n\n- **Fast Worker (prefetch=3)**: Can receive and process up to 3 tasks simultaneously\n- **Slow Worker (prefetch=1)**: Must finish one task before receiving the next\n\n**Result:** Fast worker gets more tasks from the queue proportional to its capacity.\n\n**Try it:** Click 'Send 20 Tasks' and watch how tasks are distributed based on worker capacity.",
        "x": 330,
        "y": 420,
        "wires": []
    },
    {
        "id": "priority_tab",
        "type": "tab",
        "label": "Priority Queue Example",
        "disabled": false,
        "info": "Demonstrates priority queue - High priority tasks processed before low priority"
    },
    {
        "id": "inject_high_priority",
        "type": "inject",
        "z": "priority_tab",
        "name": "High Priority Task",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 80,
        "wires": [["create_high_priority"]]
    },
    {
        "id": "inject_low_priority",
        "type": "inject",
        "z": "priority_tab",
        "name": "Low Priority Task",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 120,
        "wires": [["create_low_priority"]]
    },
    {
        "id": "inject_mixed_batch",
        "type": "inject",
        "z": "priority_tab",
        "name": "Mixed Priority Batch",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "15",
        "payloadType": "num",
        "x": 150,
        "y": 160,
        "wires": [["create_mixed_batch"]]
    },
    {
        "id": "create_high_priority",
        "type": "function",
        "z": "priority_tab",
        "name": "Create High Priority",
        "func": "const taskId = Math.floor(Math.random() * 10000);\n\nmsg.payload = {\n    taskId: taskId,\n    type: 'high_priority',\n    priority: 10,\n    data: `HIGH PRIORITY Task ${taskId}`,\n    timestamp: new Date().toISOString()\n};\n\nnode.status({fill:\"red\",shape:\"dot\",text:`High priority ${taskId}`});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 80,
        "wires": [["send_priority_queue", "debug_priority_created"]]
    },
    {
        "id": "create_low_priority",
        "type": "function",
        "z": "priority_tab",
        "name": "Create Low Priority",
        "func": "const taskId = Math.floor(Math.random() * 10000);\n\nmsg.payload = {\n    taskId: taskId,\n    type: 'low_priority',\n    priority: 1,\n    data: `Low priority task ${taskId}`,\n    timestamp: new Date().toISOString()\n};\n\nnode.status({fill:\"blue\",shape:\"dot\",text:`Low priority ${taskId}`});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 120,
        "wires": [["send_priority_queue", "debug_priority_created"]]
    },
    {
        "id": "create_mixed_batch",
        "type": "function",
        "z": "priority_tab",
        "name": "Create Mixed Batch",
        "func": "const count = msg.payload || 15;\nconst messages = [];\n\nfor (let i = 0; i < count; i++) {\n    const taskId = Math.floor(Math.random() * 10000);\n    const priority = Math.random() > 0.5 ? 10 : 1; // Random high/low\n    \n    messages.push({\n        payload: {\n            taskId: taskId,\n            type: priority === 10 ? 'high_priority' : 'low_priority',\n            priority: priority,\n            data: `${priority === 10 ? 'HIGH' : 'Low'} priority task ${taskId}`,\n            timestamp: new Date().toISOString()\n        }\n    });\n}\n\nnode.status({fill:\"blue\",shape:\"dot\",text:`Created ${count} mixed tasks`});\nreturn [messages];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 160,
        "wires": [["send_priority_queue"]]
    },
    {
        "id": "send_priority_queue",
        "type": "function",
        "z": "priority_tab",
        "name": "Send to Priority Queue",
        "func": "const amqp = global.get('amqplib') || amqplib;\nif (!global.get('amqplib')) {\n    global.set('amqplib', amqplib);\n}\n\nconst url = 'amqp://admin:rabbitmqpass123@rabbitmq:5672';\n\n(async () => {\n    try {\n        const connection = await amqp.connect(url);\n        const channel = await connection.createChannel();\n        \n        const queueName = 'priority_queue';\n        // Create queue with max priority of 10\n        await channel.assertQueue(queueName, { \n            durable: true,\n            maxPriority: 10\n        });\n        \n        const message = JSON.stringify(msg.payload);\n        const priority = msg.payload.priority || 1;\n        \n        // Send with priority\n        channel.sendToQueue(queueName, Buffer.from(message), { \n            persistent: true,\n            priority: priority\n        });\n        \n        const color = priority > 5 ? \"red\" : \"blue\";\n        node.status({fill:color,shape:\"dot\",text:`Sent priority ${priority} task ${msg.payload.taskId}`});\n        \n        setTimeout(() => {\n            channel.close();\n            connection.close();\n        }, 500);\n        \n    } catch (error) {\n        node.error(`Error: ${error.message}`, msg);\n        node.status({fill:\"red\",shape:\"ring\",text:\"error\"});\n    }\n})();\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [{"var": "amqplib", "module": "amqplib"}],
        "x": 600,
        "y": 120,
        "wires": []
    },
    {
        "id": "priority_worker",
        "type": "function",
        "z": "priority_tab",
        "name": "Priority Worker",
        "func": "const amqp = global.get('amqplib') || amqplib;\nif (!global.get('amqplib')) {\n    global.set('amqplib', amqplib);\n}\n\nconst url = 'amqp://admin:rabbitmqpass123@rabbitmq:5672';\n\nif (!context.get('priority_worker_connection')) {\n    (async () => {\n        try {\n            const connection = await amqp.connect(url);\n            const channel = await connection.createChannel();\n            \n            const queueName = 'priority_queue';\n            await channel.assertQueue(queueName, { \n                durable: true,\n                maxPriority: 10\n            });\n            channel.prefetch(1);\n            \n            channel.consume(queueName, (msg) => {\n                if (msg) {\n                    const content = msg.content.toString();\n                    try {\n                        const task = JSON.parse(content);\n                        const priority = msg.properties.priority || 1;\n                        \n                        node.status({fill:\"yellow\",shape:\"ring\",text:`Processing priority ${priority}`});\n                        \n                        node.send({\n                            payload: task,\n                            priority: priority,\n                            _msgid: msg.properties.messageId,\n                            acknowledge: () => {\n                                channel.ack(msg);\n                                node.status({fill:\"green\",shape:\"dot\",text:\"Ready\"});\n                            }\n                        });\n                    } catch (e) {\n                        node.error(`Parse error: ${e.message}`);\n                        channel.nack(msg, false, false);\n                    }\n                }\n            }, { noAck: false });\n            \n            context.set('priority_worker_connection', { connection, channel });\n            node.status({fill:\"green\",shape:\"dot\",text:\"Ready\"});\n            \n        } catch (error) {\n            node.error(`Connection error: ${error.message}`);\n            node.status({fill:\"red\",shape:\"ring\",text:\"error\"});\n        }\n    })();\n} else {\n    node.status({fill:\"green\",shape:\"dot\",text:\"Ready\"});\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "const conn = context.get('priority_worker_connection');\nif (conn) {\n    try {\n        conn.channel.close();\n        conn.connection.close();\n    } catch (e) {}\n    context.set('priority_worker_connection', null);\n}",
        "libs": [{"var": "amqplib", "module": "amqplib"}],
        "x": 150,
        "y": 280,
        "wires": [["process_priority_task"]]
    },
    {
        "id": "process_priority_task",
        "type": "function",
        "z": "priority_tab",
        "name": "Process Task",
        "func": "const task = msg.payload;\nconst priority = msg.priority || 1;\nconst acknowledge = msg.acknowledge;\n\nnode.status({fill:\"yellow\",shape:\"ring\",text:`Processing ${task.taskId} (P${priority})`});\n\nsetTimeout(() => {\n    msg.payload = {\n        ...task,\n        priority: priority,\n        status: 'completed',\n        completedAt: new Date().toISOString()\n    };\n    \n    if (acknowledge) acknowledge();\n    \n    node.status({fill:\"green\",shape:\"dot\",text:`Done ${task.taskId}`});\n    node.send(msg);\n}, 1000);\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 280,
        "wires": [["debug_priority_completed"]]
    },
    {
        "id": "start_priority_worker",
        "type": "inject",
        "z": "priority_tab",
        "name": "Start Priority Worker",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "x": 160,
        "y": 240,
        "wires": [["priority_worker"]]
    },
    {
        "id": "debug_priority_created",
        "type": "debug",
        "z": "priority_tab",
        "name": "Task Created",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 610,
        "y": 40,
        "wires": []
    },
    {
        "id": "debug_priority_completed",
        "type": "debug",
        "z": "priority_tab",
        "name": "Task Completed",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 550,
        "y": 280,
        "wires": []
    },
    {
        "id": "comment_priority",
        "type": "comment",
        "z": "priority_tab",
        "name": "Priority Queue: High priority (10) tasks processed before low priority (1) tasks",
        "info": "**How Priority Queue Works:**\n\n- Queue configured with `maxPriority: 10`\n- Messages sent with priority 1-10\n- Higher priority messages delivered first\n- If multiple messages have same priority, FIFO order\n\n**Try it:** \n1. Send several low priority tasks\n2. Then send high priority tasks\n3. Watch high priority tasks get processed first",
        "x": 350,
        "y": 340,
        "wires": []
    },
    {
        "id": "dlq_tab",
        "type": "tab",
        "label": "Dead Letter Queue Example",
        "disabled": false,
        "info": "Demonstrates dead letter queue - Failed tasks automatically routed to error queue"
    },
    {
        "id": "inject_dlq_task",
        "type": "inject",
        "z": "dlq_tab",
        "name": "Send Normal Task",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 80,
        "wires": [["create_dlq_task"]]
    },
    {
        "id": "inject_failing_task",
        "type": "inject",
        "z": "dlq_tab",
        "name": "Send Failing Task",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "fail",
        "payloadType": "str",
        "x": 140,
        "y": 120,
        "wires": [["create_failing_task"]]
    },
    {
        "id": "create_dlq_task",
        "type": "function",
        "z": "dlq_tab",
        "name": "Create Normal Task",
        "func": "const taskId = Math.floor(Math.random() * 10000);\n\nmsg.payload = {\n    taskId: taskId,\n    type: 'normal',\n    shouldFail: false,\n    data: `Normal task ${taskId}`,\n    timestamp: new Date().toISOString()\n};\n\nnode.status({fill:\"green\",shape:\"dot\",text:`Created task ${taskId}`});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 80,
        "wires": [["send_dlq_queue", "debug_dlq_created"]]
    },
    {
        "id": "create_failing_task",
        "type": "function",
        "z": "dlq_tab",
        "name": "Create Failing Task",
        "func": "const taskId = Math.floor(Math.random() * 10000);\n\nmsg.payload = {\n    taskId: taskId,\n    type: 'failing',\n    shouldFail: true,\n    data: `Failing task ${taskId}`,\n    timestamp: new Date().toISOString()\n};\n\nnode.status({fill:\"red\",shape:\"dot\",text:`Created failing task ${taskId}`});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 120,
        "wires": [["send_dlq_queue", "debug_dlq_created"]]
    },
    {
        "id": "send_dlq_queue",
        "type": "function",
        "z": "dlq_tab",
        "name": "Send to Main Queue",
        "func": "const amqp = global.get('amqplib') || amqplib;\nif (!global.get('amqplib')) {\n    global.set('amqplib', amqplib);\n}\n\nconst url = 'amqp://admin:rabbitmqpass123@rabbitmq:5672';\n\n(async () => {\n    try {\n        const connection = await amqp.connect(url);\n        const channel = await connection.createChannel();\n        \n        // First, assert the dead letter exchange\n        await channel.assertExchange('dlx', 'direct', { durable: true });\n        \n        // Assert the dead letter queue\n        await channel.assertQueue('dead_letter_queue', { durable: true });\n        \n        // Bind dead letter queue to exchange\n        await channel.bindQueue('dead_letter_queue', 'dlx', 'dead');\n        \n        // Assert main queue with DLX configuration\n        const queueName = 'main_queue';\n        await channel.assertQueue(queueName, { \n            durable: true,\n            deadLetterExchange: 'dlx',\n            deadLetterRoutingKey: 'dead',\n            messageTtl: 60000 // Optional: messages expire after 60s\n        });\n        \n        const message = JSON.stringify(msg.payload);\n        channel.sendToQueue(queueName, Buffer.from(message), { persistent: true });\n        \n        const color = msg.payload.shouldFail ? \"red\" : \"green\";\n        node.status({fill:color,shape:\"dot\",text:`Sent task ${msg.payload.taskId}`});\n        \n        setTimeout(() => {\n            channel.close();\n            connection.close();\n        }, 500);\n        \n    } catch (error) {\n        node.error(`Error: ${error.message}`, msg);\n        node.status({fill:\"red\",shape:\"ring\",text:\"error\"});\n    }\n})();\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [{"var": "amqplib", "module": "amqplib"}],
        "x": 570,
        "y": 100,
        "wires": []
    },
    {
        "id": "main_worker",
        "type": "function",
        "z": "dlq_tab",
        "name": "Main Worker",
        "func": "const amqp = global.get('amqplib') || amqplib;\nif (!global.get('amqplib')) {\n    global.set('amqplib', amqplib);\n}\n\nconst url = 'amqp://admin:rabbitmqpass123@rabbitmq:5672';\n\nif (!context.get('main_worker_connection')) {\n    (async () => {\n        try {\n            const connection = await amqp.connect(url);\n            const channel = await connection.createChannel();\n            \n            // Setup dead letter exchange and queue first\n            await channel.assertExchange('dlx', 'direct', { durable: true });\n            await channel.assertQueue('dead_letter_queue', { durable: true });\n            await channel.bindQueue('dead_letter_queue', 'dlx', 'dead');\n            \n            const queueName = 'main_queue';\n            await channel.assertQueue(queueName, { \n                durable: true,\n                deadLetterExchange: 'dlx',\n                deadLetterRoutingKey: 'dead',\n                messageTtl: 60000\n            });\n            channel.prefetch(1);\n            \n            channel.consume(queueName, (msg) => {\n                if (msg) {\n                    const content = msg.content.toString();\n                    try {\n                        const task = JSON.parse(content);\n                        \n                        node.status({fill:\"yellow\",shape:\"ring\",text:`Processing ${task.taskId}`});\n                        \n                        node.send({\n                            payload: task,\n                            _msgid: msg.properties.messageId,\n                            acknowledge: () => channel.ack(msg),\n                            reject: () => {\n                                // Reject without requeue - goes to DLQ\n                                channel.nack(msg, false, false);\n                            }\n                        });\n                    } catch (e) {\n                        node.error(`Parse error: ${e.message}`);\n                        channel.nack(msg, false, false);\n                    }\n                }\n            }, { noAck: false });\n            \n            context.set('main_worker_connection', { connection, channel });\n            node.status({fill:\"green\",shape:\"dot\",text:\"Ready\"});\n            \n        } catch (error) {\n            node.error(`Connection error: ${error.message}`);\n            node.status({fill:\"red\",shape:\"ring\",text:\"error\"});\n        }\n    })();\n} else {\n    node.status({fill:\"green\",shape:\"dot\",text:\"Ready\"});\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "const conn = context.get('main_worker_connection');\nif (conn) {\n    try {\n        conn.channel.close();\n        conn.connection.close();\n    } catch (e) {}\n    context.set('main_worker_connection', null);\n}",
        "libs": [{"var": "amqplib", "module": "amqplib"}],
        "x": 140,
        "y": 240,
        "wires": [["process_dlq_task"]]
    },
    {
        "id": "process_dlq_task",
        "type": "function",
        "z": "dlq_tab",
        "name": "Process Task",
        "func": "const task = msg.payload;\nconst acknowledge = msg.acknowledge;\nconst reject = msg.reject;\n\nnode.status({fill:\"yellow\",shape:\"ring\",text:`Processing ${task.taskId}`});\n\nsetTimeout(() => {\n    // Simulate random failures or intentional failures\n    const shouldFail = task.shouldFail || Math.random() < 0.1;\n    \n    if (shouldFail) {\n        // Task failed - reject to DLQ\n        node.status({fill:\"red\",shape:\"ring\",text:`Failed ${task.taskId}`});\n        \n        msg.payload = {\n            ...task,\n            status: 'failed',\n            error: 'Processing error occurred',\n            failedAt: new Date().toISOString()\n        };\n        \n        if (reject) reject();\n        node.send([null, msg]); // Send to output 2 (error)\n    } else {\n        // Task succeeded\n        node.status({fill:\"green\",shape:\"dot\",text:`Completed ${task.taskId}`});\n        \n        msg.payload = {\n            ...task,\n            status: 'completed',\n            completedAt: new Date().toISOString()\n        };\n        \n        if (acknowledge) acknowledge();\n        node.send([msg, null]); // Send to output 1 (success)\n    }\n}, 1000);\n\nreturn null;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 240,
        "wires": [["debug_dlq_success"], ["debug_dlq_failed"]]
    },
    {
        "id": "dlq_consumer",
        "type": "function",
        "z": "dlq_tab",
        "name": "DLQ Consumer",
        "func": "const amqp = global.get('amqplib') || amqplib;\nif (!global.get('amqplib')) {\n    global.set('amqplib', amqplib);\n}\n\nconst url = 'amqp://admin:rabbitmqpass123@rabbitmq:5672';\n\nif (!context.get('dlq_consumer_connection')) {\n    (async () => {\n        try {\n            const connection = await amqp.connect(url);\n            const channel = await connection.createChannel();\n            \n            await channel.assertExchange('dlx', 'direct', { durable: true });\n            await channel.assertQueue('dead_letter_queue', { durable: true });\n            await channel.bindQueue('dead_letter_queue', 'dlx', 'dead');\n            \n            channel.consume('dead_letter_queue', (msg) => {\n                if (msg) {\n                    const content = msg.content.toString();\n                    try {\n                        const task = JSON.parse(content);\n                        \n                        node.status({fill:\"orange\",shape:\"dot\",text:`DLQ: ${task.taskId}`});\n                        \n                        // Process dead letter - could log, alert, retry, etc.\n                        node.send({\n                            payload: {\n                                ...task,\n                                dlqReceivedAt: new Date().toISOString(),\n                                originalDeliveryInfo: {\n                                    exchange: msg.fields.exchange,\n                                    routingKey: msg.fields.routingKey\n                                }\n                            }\n                        });\n                        \n                        channel.ack(msg);\n                    } catch (e) {\n                        node.error(`DLQ Parse error: ${e.message}`);\n                        channel.ack(msg); // Ack anyway to prevent infinite loop\n                    }\n                }\n            }, { noAck: false });\n            \n            context.set('dlq_consumer_connection', { connection, channel });\n            node.status({fill:\"orange\",shape:\"dot\",text:\"DLQ Ready\"});\n            \n        } catch (error) {\n            node.error(`DLQ Connection error: ${error.message}`);\n            node.status({fill:\"red\",shape:\"ring\",text:\"error\"});\n        }\n    })();\n} else {\n    node.status({fill:\"orange\",shape:\"dot\",text:\"DLQ Ready\"});\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "const conn = context.get('dlq_consumer_connection');\nif (conn) {\n    try {\n        conn.channel.close();\n        conn.connection.close();\n    } catch (e) {}\n    context.set('dlq_consumer_connection', null);\n}",
        "libs": [{"var": "amqplib", "module": "amqplib"}],
        "x": 140,
        "y": 340,
        "wires": [["debug_dlq_received"]]
    },
    {
        "id": "start_main_worker",
        "type": "inject",
        "z": "dlq_tab",
        "name": "Start Main Worker",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "x": 150,
        "y": 200,
        "wires": [["main_worker"]]
    },
    {
        "id": "start_dlq_consumer",
        "type": "inject",
        "z": "dlq_tab",
        "name": "Start DLQ Consumer",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "x": 160,
        "y": 380,
        "wires": [["dlq_consumer"]]
    },
    {
        "id": "debug_dlq_created",
        "type": "debug",
        "z": "dlq_tab",
        "name": "Task Created",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 570,
        "y": 40,
        "wires": []
    },
    {
        "id": "debug_dlq_success",
        "type": "debug",
        "z": "dlq_tab",
        "name": "Success",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 220,
        "wires": []
    },
    {
        "id": "debug_dlq_failed",
        "type": "debug",
        "z": "dlq_tab",
        "name": "Failed (to DLQ)",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 540,
        "y": 260,
        "wires": []
    },
    {
        "id": "debug_dlq_received",
        "type": "debug",
        "z": "dlq_tab",
        "name": "Dead Letter Received",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 350,
        "y": 340,
        "wires": []
    },
    {
        "id": "comment_dlq",
        "type": "comment",
        "z": "dlq_tab",
        "name": "Dead Letter Queue: Failed tasks automatically routed to error queue for handling",
        "info": "**How Dead Letter Queue Works:**\n\n1. Main queue configured with `deadLetterExchange` and `deadLetterRoutingKey`\n2. When a message is rejected (nack with requeue=false), it goes to DLQ\n3. Also messages that expire (TTL) go to DLQ\n4. Separate consumer handles dead letters for logging, alerting, or retry\n\n**Use Cases:**\n- Error handling and monitoring\n- Failed message inspection\n- Retry mechanisms\n- Alerting on failures\n\n**Try it:** Send failing tasks and watch them appear in DLQ",
        "x": 330,
        "y": 420,
        "wires": []
    }
]
